ex. on p. 24

// jobs event loop ex for review

console.log( "A" );
setTimeout( function(){
 console.log( "B" );
}, 0 );
// theoretical "Job API"
schedule( function(){
 console.log( "C" );
 schedule( function(){
 console.log( "D" );
 } );
} );

Callback: the ansync workhorse of js (many apps have been developed with only this as a pattern ie no promises or async/await/try/catch)
	- that's the reason for discussing

Think about how you would describe what will happen with this code	
// A
setTimeout( function(){
 // C
}, 1000 );
// B 

Simple ex. but we've seen a lot more complex. Why do we hear about callback hell or have difficulty reasoning about it
	- Something analagous is how people refer to multitasking in how our brains think
	- Going to the grocery store
		-started an action and while we wait
		-turn on radio
		-interrupted by call from mom
		-encountered an error (forgot wallet at home)
		-handle error return to fetch it
	- not multitasking but managing rapid context switching
		-This should make it easier to have an obvious mental model of async in code but it doesn't really
	- with our thought process it is like a single threaded event loop in action,but not in planning which is what makes it difficult to reason about in code

example of ordering issues
analyze this as async, sync, or a mix
async: a, f, b, c, e, d
sync: a, b, c, d, e, f
mixed only c async: a, b, c, e, d, f

doA( function(){
 doB();
 doC( function(){
	doD();
 } )
 doE();
} );
doF();


trust issues
//works and then turns out it charged someon 5 times
//retry logic was introduced in 3rd party function
analytics.trackPurchase( purchaseData, function(){
 chargeCreditCard();
 displayThankyouPage();
} );

//solution

var tracked = false;
analytics.trackPurchase( purchaseData, function(){
 if (!tracked) {
 tracked = true;
 chargeCreditCard();
 displayThankyouPage();
 }
} );

other potential issues:
-called to early
-called too late
-called too few or too many times
-swallowed errors

Solutions ex for error handling

SPLIT CALLBACKS
function success(data) {
 console.log( data );
}

function failure(err) {
 console.error( err );
}
ajax( "http://some.url.1", success, failure );


ERROR FIRST STYLE
function response(err,data) {
 // error?
 if (err) {
 console.error( err );
 }
 // otherwise, assume success
 else {
 console.log( data );
 }
}
ajax( "http://some.url.1", response );

WHAT ABOUT NEVER BEING CALLED

function timeoutify(fn,delay) {
 var intv = setTimeout( function(){
 intv = null;
 fn( new Error( "Timeout!" ) );
 }, delay )
 ;
 return function() {
 // timeout hasn't happened yet?
 if (intv) {
 clearTimeout( intv );
 fn.apply( this, arguments );
 }
 };
}
Hereâ€™s how you use it:
// using "error-first style" callback design
function foo(err,data) {
 if (err) {
 console.error( err );
 }
 else {
 console.log( data );
 }
}
ajax( "http://some.url.1", timeoutify( foo, 500 ) );




?code challenge
?test repos

- current testing discussion
	- any issues?
	- anything to share from dev worth pushing and describing?